/*
 * This code has been generated by the Rebel: a code generator for modern Java.
 * 
 * For more details, please visit www.archetypesoftware.com.
 *
 * Drop us a line or two at feedback@archetypesoftware.com. We would love to hear from you.
 */
package rebel;

import java.util.Scanner;

import boundaries.ChooseYourXPositionForm;
import boundaries.ChooseYourYPositionForm;
import boundaries.DecideToStartOrToQuitForm;
import boundaries.GameBoardDisplay;
import boundaries.IllegalMoveMessage;
import boundaries.NotYourTurnMessage;
import boundaries.PlayerCheckForm;
import boundaries.PlayerOneMoveMessage;
import boundaries.PlayerTwoMoveMessage;
import boundaries.QuitMessage;
import boundaries.RestartGameForm;
import boundaries.ResultsMessage;

import rebel.Constants.*;


public class PlayGameController {
	private int currentPlayer = 2;
	private BoardData boardData = new BoardData();
	private Scanner sc = new Scanner(System.in);

	public PlayGameController() {
		DecideToStartOrToQuitForm decideForm = new DecideToStartOrToQuitForm();
		int decisionResult = decideForm.choose(sc);
		if(decisionResult == Constants.START_CODE)
			playGame();
		else if(decisionResult == Constants.QUIT_CODE)
			quitGame();
	}

	public void playGame() {
		int x, y, currentPlayerAccordingToBoard, playerTryingToMove;
		int restartGame;
		boolean notYourTurn;
		boolean legalMove;
		Scanner sc = new Scanner(System.in);
		PlayerCheckForm playerCheckForm = new PlayerCheckForm();
		RestartGameForm restartForm= new RestartGameForm();
		ChooseYourXPositionForm chooseX = new ChooseYourXPositionForm();
		ChooseYourYPositionForm chooseY = new ChooseYourYPositionForm();
		GameBoardDisplay boardDisplay = new GameBoardDisplay();
		PlayerTwoMoveMessage msg2Move = new PlayerTwoMoveMessage();
		PlayerOneMoveMessage msg1Move = new PlayerOneMoveMessage();

		do {
			boardData.switchPlayer();
			currentPlayerAccordingToBoard = boardData.getCurrentPlayer();

			if(currentPlayerAccordingToBoard == Constants.FIRST_PLAYER)
				msg1Move.playerOneMoveMessage();
			else if(currentPlayerAccordingToBoard == Constants.SECOND_PLAYER)
				msg2Move.playerTwoMoveMesage();

			do {
				playerTryingToMove = playerCheckForm.check(sc);

				if(playerTryingToMove != currentPlayerAccordingToBoard) {
					new NotYourTurnMessage();
					notYourTurn = true;
				}
				else
					notYourTurn = false;
			}while (notYourTurn == true);

			do{
				x = chooseX.choose(currentPlayerAccordingToBoard, sc);
				y = chooseY.choose(currentPlayerAccordingToBoard, sc);


				if(boardData.isRubricAvailable(x, y)) {
					move(x,y);
					legalMove = true;
				}
				else {
					new IllegalMoveMessage();
					legalMove = false;
				}
			}while(legalMove == false);
			boardDisplay.presentBoard(boardData, boardData.getN());


			restartGame = restartForm.restartcheck(sc);
			if(restartGame == Constants.AGREE_TO_RESTART_CODE)
				restartGame();
		}
		while (!boardData.checkDraw() && !boardData.checkWin(x,y));
		results();
	}

	public void move(int x, int y) {
		boardData.registerMove(x, y, State.values()[boardData.getCurrentPlayer()]);
	}

	
	public void results() {
		if(boardData.checkDraw()) {
			new ResultsMessage(0);
		}
		else {
			int winner = boardData.getCurrentPlayer();
			new ResultsMessage(winner);
		}
	}

	public void switchPlayer() {
		if(currentPlayer == Constants.FIRST_PLAYER)
			currentPlayer = Constants.SECOND_PLAYER;
		else if (currentPlayer == Constants.SECOND_PLAYER)
			currentPlayer = Constants.FIRST_PLAYER;
	}
	
	public void quitGame() {
		sc.close();
		new QuitMessage();
		System.exit(0);
	}
	public void restartGame() {
		boardData.cleanBoard();
	}
}